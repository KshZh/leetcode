# [「算法入门笔记」卡特兰数](https://leetcode-cn.com/circle/article/lWYCzv/)

## 一、引言

卡特兰数（Catalan number）是组合数学中一个常出现在各种计数问题中的数列。

数列的前几项为：1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862，...

本文将会选取几个经典的卡特兰问题，难度先易后难，带领读者逐个击破解决，最后给出相关的解题模板。

## 二、经典问题

### 2.1 进出栈序列

这是一道最经典的入门级卡特兰数题目，如果能把这题看懂，相信后面的题目也能迎刃而解。

题目描述

n 个元素进栈序列为：1，2，3，4，...，n，则有多少种出栈序列

思路

我们将进栈表示为 +1，出栈表示为 -1，则 1 3 2 的出栈序列可以表示为：+1 -1 +1 +1 -1 -1。

根据栈本身的特点，每次出栈的时候，必定之前有元素入栈，即对于每个 -1 前面都有一个 +1 相对应。因此，出栈序列的所有前缀和必然大于等于 0，并且 +1 的数量等于 -1 的数量。对于n个元素，则出栈序列长度为2n。

接下来让我们观察一下 n = 3 的一种出栈序列：+1 -1 -1 +1 -1 +1。序列前三项和小于 0，显然这是个非法的序列。

如果将第一个前缀和小于 0 的前缀，即前三项元素都进行取反，就会得到：-1 +1 +1 +1 -1 +1。此时有 3 + 1 个 +1 以及 3 - 1 个 -1。

因为这个第一个小于 0 的前缀和必然是 -1，且 -1 比 +1 多一个，取反后，-1 比 +1 少一个，则 +1 变为 n + 1 个，且 -1 变为 n - 1 个。进一步推广，对于 n 元素的每种非法出栈序列，都会对应一个含有 n + 1 个 +1 以及 n - 1 个 -1 的序列。

如何证明这两种序列是一一对应的？

假设非法序列为 A，对应的序列为 B。每个 A 只有一个"第一个前缀和小于 0 的前缀"，所以每个 A 只能产生一个 B。而每个 B 想要还原到 A，就需要找到"第一个前缀和大于 0 的前缀"，显然 B 也只能产生一个 A。

每个 B 都有 n + 1 个 +1 以及 n - 1 个 -1，因此 B 的数量为  C(2n, n+1)，相当于在长度为 2n 的序列中找到 n + 1 个位置存放 +1。相应的，非法序列的数量也就等于 C(2n, n+1)。

出栈序列的总数量共有 C(2n, n)，因此，合法的出栈序列的数量为  C(2n, n)-C(2n, n+1)=C(2n, n)/(n+1)。这就是卡特兰数的通项公式。

关于上面这个式子的化简如下，只需简单地展开即可：
$$
A_m^n = m*(m-1)*...*(m-n+1) = \frac{m!}{(m-n)!} 即第一个位置有m种选择，第二个位置有(m-1)种选择。\\C_m^n = \frac{A_m^n}{A_n^n} = \frac{m!}{(m-n)!*n!} 即去掉顺序的排列就是组合，选出来的n个元素有A_n^n中不同的排列顺序，但这些都是同一种组合，所以对于每选出的n个元素，要除掉A_n^n只算一次。\\C_{2n}^{n+1} = \frac{(2n)!}{(n+1)!*(n-1)!} 上下同乘一个n，得到\frac{C_{2n}^{n+1}}{1+\frac{1}{n}}，然后(\frac{1+\frac{1}{n}}{1+\frac{1}{n}}-\frac{1}{1+\frac{1}{n}})C_{2n}^{n+1}。
$$

### 2.2 括号序列

题目描述

n 对括号，则有多少种 “括号匹配” 的括号序列

思路

左括号看成 +1，右括号看成 -1，那么就和上题的进出栈一样，共有 C(2n, n)/(n+1) 种序列。



## 代码实现

```cpp
#include <iostream>
using namespace std;

long f(int n) {
	long x, i;
    // C(2n, n)/(n+1) = (2n)!/((n!)*(n!)*(n+1))，可以消掉一个n!。
	for (x=i=1; i<=n; i++) {
		x = x*(i+n)/i;
	}
	return x/i; // 最后再除一个n+1。
}

int main() {
	long n;
	cin >> n;
	cout << f(n) << endl;
}
```
