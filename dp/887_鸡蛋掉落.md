# [887. 鸡蛋掉落](https://leetcode-cn.com/problems/super-egg-drop/)

> 你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N  共有 N 层楼的建筑。
>
> 每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。
>
> 你知道存在楼层 F ，满足 0 <= F <= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。
>
> 每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 <= X <= N）。
>
> 你的目标是确切地知道 F 的值是多少。
>
> 无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？
>
> 示例 1：
>
> 输入：K = 1, N = 2
> 输出：2
> 解释：
> 鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。
> 否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。
> 如果它没碎，那么我们肯定知道 F = 2 。
> 因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。
> 示例 2：
>
> 输入：K = 2, N = 6
> 输出：3
> 示例 3：
>
> 输入：K = 3, N = 14
> 输出：4
>
>
> 提示：
>
> 1 <= K <= 100
> 1 <= N <= 10000
>

1. Hard。
2. [《复工复产找工作？先来看看这道面试题：双蛋问题》](https://www.bilibili.com/video/BV1KE41137PK?from=search&seid=17973611971894816621)

![fig1](https://assets.leetcode-cn.com/solution-static/887_fig1.jpg)

```java
// 时间复杂度是为 O(KN^2)，即一共有 O(KN) 个状态（二维表格的大小），对于每个状态枚举扔鸡蛋的楼层 X，需要 O(N) 的时间。
// 超时。
class Solution {
    public int superEggDrop(int K, int N) {
        // 在K个鸡蛋中拿出一个，从楼层X扔下，那么有两种可能，一种是碎了，那么楼层F就在[1, X)共X-1层楼中，另一种是没碎，那么楼层F就在[X, N]共N-X+1层楼中，而楼层X已经测试了，所以只需要测试往上N-X层楼，且鸡蛋没碎，还可以继续使用。
        // 用dp[i][j]表示有i个鸡蛋，j层楼，确定楼层F所需的最少扔鸡蛋次数。
        // 那么状态转移方程：dp[i][j]=1+min_x(max(dp[i-1][x-1], dp[i][j-x]))，
        // 注意要在两种子问题中取最大值，这是因为在楼层X扔下，可能碎也可能不碎，我们必须保证最坏情况下，保证能够检测出楼层F的扔鸡蛋次数。然后，取最小值，看在哪个楼层扔鸡蛋，可以用最少的扔鸡蛋次数确定楼层F。
        int[][] dp = new int[K+1][N+1];
        // 边界：
        for (int j=1; j<N+1; j++) {
            // 只有一个鸡蛋的话，楼层数为j，最坏情况下楼层F在最高层，
            // 需要从最底层开始检测，最坏情况下至少需要j次检测。
            dp[1][j] = j;
        }
        for (int i=1; i<K+1; i++) {
            // 只有一层楼，那无论有多少个鸡蛋，都需要至少检测一次。
            dp[i][1] = 1;
        }
        for (int i=2; i<K+1; i++) {
            for (int j=2; j<N+1; j++) {
                dp[i][j] = Integer.MAX_VALUE;
                for (int x=1; x<=j; x++) {
                    dp[i][j] = Math.min(dp[i][j], Math.max(dp[i-1][x-1], dp[i][j-x]));
                }
                dp[i][j]++;
            }
        }
        return dp[K][N];
    }
}
```

```java
// 这样一来，对于给定的状态 (K,N)，我们只需要 O(logN) 的时间，通过二分查找就能得到最优的那个 X，因此时间复杂度从 O(KN^2)  降低至 O(KNlogN)，可以通过本题。
class Solution {
    public int superEggDrop(int K, int N) {
        // 在K个鸡蛋中拿出一个，从楼层X扔下，那么有两种可能，一种是碎了，那么楼层F就在[1, X)共X-1层楼中，另一种是没碎，那么楼层F就在[X, N]共N-X+1层楼中，而楼层X已经测试了，所以只需要测试往上N-X层楼，且鸡蛋没碎，还可以继续使用。
        // 用dp[i][j]表示有i个鸡蛋，j层楼，确定楼层F所需的最少扔鸡蛋次数。
        // 那么状态转移方程：dp[i][j]=1+min_x(max(dp[i-1][x-1], dp[i][j-x]))，
        // 注意要在两种子问题中取最大值，这是因为在楼层X扔下，可能碎也可能不碎，我们必须保证最坏情况下，保证能够检测出楼层F的扔鸡蛋次数。然后，取最小值，看在哪个楼层扔鸡蛋，可以用最少的扔鸡蛋次数确定楼层F。
        int[][] dp = new int[K+1][N+1];
        // 边界：
        for (int j=1; j<N+1; j++) {
            // 只有一个鸡蛋的话，楼层数为j，最坏情况下楼层F在最高层，
            // 需要从最底层开始检测，最坏情况下至少需要j次检测。
            dp[1][j] = j;
        }
        for (int i=1; i<K+1; i++) {
            // 只有一层楼，那无论有多少个鸡蛋，都需要至少检测一次。
            dp[i][1] = 1;
        }
        int l, r, x, t1, t2;
        for (int i=2; i<K+1; i++) {
            for (int j=2; j<N+1; j++) {
                // 值得学习的二分实现，这里的二分法要找出靠近交点的左右两个端点，最终存放在l和r中。
                l=1; r=j;
                while (l + 1 < r) {
                    x = l + (r-l)/2;
                    t1 = dp[i-1][x-1];
                    t2 = dp[i][j-x];
                    if (t1 < t2)
                        l = x; // 靠近交点的左端点候选，先用l暂存，并继续往右边找，试图找到一个更靠近交点的左端点。
                    else if (t1 > t2)
                        r = x; // 同理。
                    else
                        l = r = x; // 交点刚好是整数，那么最靠近交点的左右端点就是交点本身了。
                }
                dp[i][j] = 1 + Math.min(Math.max(dp[i-1][l-1], dp[i][j-l]),
                                   Math.max(dp[i-1][r-1], dp[i][j-r]));
            }
        }
        return dp[K][N];
    }
}
```

