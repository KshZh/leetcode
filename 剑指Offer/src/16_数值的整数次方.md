# 16. 数值的整数次方

> 实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。
>
> 示例 1:
>
> 输入: 2.00000, 10
> 输出: 1024.00000
> 示例 2:
>
> 输入: 2.10000, 3
> 输出: 9.26100
> 示例 3:
>
> 输入: 2.00000, -2
> 输出: 0.25000
> 解释: 2-2 = 1/22 = 1/4 = 0.25
>
>
> 说明:
>
> -100.0 < x < 100.0
> n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。
>

1. Medium。

```java
// 二进制角度：
// a^n = a^(2^0*b0+2^1*b1+...+2^m*bm)=a^(2^0*b0)*a^(2^1*b1)*...*a^(2^m*bm).
// 所以循环过程中，不断通过`x*=x`计算出x^(2^i*bi)，然后查看bi为0还是为1，若为1，则累乘到res中，否则处理b(i+1)。
// 二分角度：
// 当n为偶数时，a^n=(a^2)^(n/2)，当n为奇数时，a^n=a*(a^2)^(n/2)。
// `n_&1==`等价于`n_%2==1`，`n_>>=1`等价于`n_/=2`。
// 事实上，二分角度使用递归实现更对应和直观。
class Solution {
    public double myPow(double x, int n) {
        long n_ = n;
        if (n < 0) {
            // 把负号移进去。
            x = 1/x;
            // 当n为Math.MIN_VALUE时，取反在正数区间找不到对应的数，所以直接把n存在long中。
            n_ = -n_;
        }
        double res = 1;
        while (n_ != 0) {
            if ((n_&1) == 1) res *= x; // 指数该位为1，把“底数”乘到结果res中。
            x *= x; // 底数不断自乘。
            n_ >>= 1;
        }
        return res;
    }
}
// 通俗一点就是，3^13=3^(1+4+8)=3^1 * 3^4 * 3^8，通过循环，每次通过x*=x计算出x^1, x^2, x^4, x^8, x^16，如果指数13在某一位a上为1，则累乘上x^(2^a)。
```

